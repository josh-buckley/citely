"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/number-flow";
exports.ids = ["vendor-chunks/number-flow"];
exports.modules = {

/***/ "(ssr)/./node_modules/number-flow/dist/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/number-flow/dist/index.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberFlowLite: () => (/* binding */ kt),\n/* harmony export */   canAnimate: () => (/* binding */ St),\n/* harmony export */   define: () => (/* binding */ Et),\n/* harmony export */   partitionParts: () => (/* binding */ Mt),\n/* harmony export */   prefersReducedMotion: () => (/* binding */ Q),\n/* harmony export */   render: () => (/* binding */ Nt)\n/* harmony export */ });\nfunction s(a, t, e, i) {\n  if (e === \"a\" && !i) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof t == \"function\" ? a !== t || !i : !t.has(a)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return e === \"m\" ? i : e === \"a\" ? i.call(a) : i ? i.value : t.get(a);\n}\nfunction h(a, t, e, i, n) {\n  if (i === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (i === \"a\" && !n) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof t == \"function\" ? a !== t || !n : !t.has(a)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return i === \"a\" ? n.call(a, e) : n ? n.value = e : t.set(a, e), e;\n}\nconst F = typeof window < \"u\", w = (a, t, e) => {\n  const i = document.createElement(a), [n, r] = Array.isArray(t) ? [void 0, t] : [t, e];\n  return n && Object.assign(i, n), r == null || r.forEach((l) => i.appendChild(l)), i;\n}, pt = (a, t) => {\n  var e;\n  return t === \"left\" ? a.offsetLeft : (((e = a.offsetParent instanceof HTMLElement ? a.offsetParent : null) == null ? void 0 : e.offsetWidth) ?? 0) - a.offsetWidth - a.offsetLeft;\n}, ut = (a) => a.offsetWidth > 0 && a.offsetHeight > 0, Et = (a, t) => {\n  if (!(!F || customElements.get(a) === t))\n    return customElements.define(a, t);\n};\nfunction mt(a, t, { reverse: e = !1 } = {}) {\n  const i = a.length;\n  for (let n = e ? i - 1 : 0; e ? n >= 0 : n < i; e ? n-- : n++)\n    t(a[n], n);\n}\nfunction Mt(a, t) {\n  const e = t.formatToParts(a), i = [], n = [], r = [], l = [], o = {}, p = (c) => {\n    const f = o[c] == null ? o[c] = 0 : ++o[c];\n    return `${c}:${f}`;\n  };\n  let u = \"\", m = !1, N = !1;\n  for (const c of e) {\n    u += c.value;\n    const f = c.type === \"minusSign\" || c.type === \"plusSign\" ? \"sign\" : c.type;\n    f === \"integer\" ? (m = !0, n.push(...c.value.split(\"\").map((J) => ({ type: f, value: parseInt(J) })))) : f === \"group\" ? n.push({ type: f, value: c.value }) : f === \"decimal\" ? (N = !0, r.push({ type: f, value: c.value, key: p(f) })) : f === \"fraction\" ? r.push(...c.value.split(\"\").map((J) => ({\n      type: f,\n      value: parseInt(J),\n      key: p(f),\n      place: -1 - o[f]\n    }))) : (m || N ? l : i).push({\n      type: f,\n      value: c.value,\n      key: p(f)\n    });\n  }\n  const d = [];\n  for (let c = n.length - 1; c >= 0; c--) {\n    const f = n[c];\n    d.unshift(f.type === \"integer\" ? {\n      ...f,\n      key: p(f.type),\n      place: o[f.type]\n    } : {\n      ...f,\n      key: p(f.type)\n    });\n  }\n  return {\n    pre: i,\n    integer: d,\n    fraction: r,\n    post: l,\n    formatted: u,\n    value: typeof a == \"string\" ? parseFloat(a) : a\n  };\n}\nconst gt = String.raw, wt = F && typeof CSS < \"u\" && CSS.supports(\"animation-timing-function\", \"linear(1,2)\"), yt = F && typeof CSS < \"u\" && CSS.supports(\"line-height\", \"mod(1,1)\"), Q = F ? matchMedia(\"(prefers-reduced-motion: reduce)\") : null, Z = \"--_number-flow-d-opacity\", nt = \"--_number-flow-d-width\", q = \"--_number-flow-dx\", at = \"--_number-flow-d\", _t = (() => {\n  try {\n    return CSS.registerProperty({\n      name: Z,\n      syntax: \"<number>\",\n      inherits: !1,\n      initialValue: \"0\"\n    }), CSS.registerProperty({\n      name: q,\n      syntax: \"<length>\",\n      inherits: !0,\n      initialValue: \"0px\"\n    }), CSS.registerProperty({\n      name: nt,\n      syntax: \"<number>\",\n      inherits: !1,\n      initialValue: \"0\"\n    }), CSS.registerProperty({\n      name: at,\n      syntax: \"<number>\",\n      inherits: !0,\n      initialValue: \"0\"\n    }), !0;\n  } catch {\n    return !1;\n  }\n})(), ht = \"var(--number-flow-char-height, 1em)\", g = \"var(--number-flow-mask-height, 0.25em)\", C = `calc(${g} / 2)`, tt = \"var(--number-flow-mask-width, 0.5em)\", S = `calc(${tt} / var(--scale-x))`, D = \"#000 0, transparent 71%\", et = \"span\", ot = gt`:host{display:inline-flex;align-items:baseline;direction:ltr;white-space:nowrap;position:relative;line-height:${ht} !important;isolation:isolate;}::slotted(${et}){position:absolute;left:0;top:0;color:transparent !important;will-change:unset !important;z-index:-5;}:host > .number,:host > .section{pointer-events:none;user-select:none;}.number,.number__inner{display:inline-flex;align-items:baseline;transform-origin:left top;}:host([data-will-change]) .number,:host([data-will-change]) .number__inner{will-change:transform;}.number{--scale-x:calc(1 + var(${nt}) / var(--width));transform:translateX(var(${q})) scaleX(var(--scale-x));margin:0 calc(-1 * ${tt});position:relative;z-index:-1;overflow:clip;-webkit-mask-image:linear-gradient( to right,transparent 0,#000 ${S},#000 calc(100% - ${S}),transparent ),linear-gradient( to bottom,transparent 0,#000 ${g},#000 calc(100% - ${g}),transparent 100% ),radial-gradient(at bottom right,${D}),radial-gradient(at bottom left,${D}),radial-gradient(at top left,${D}),radial-gradient(at top right,${D});-webkit-mask-size:100% calc(100% - ${g} * 2),calc(100% - ${S} * 2) 100%,${S} ${g},${S} ${g},${S} ${g},${S} ${g};-webkit-mask-position:center,center,top left,top right,bottom right,bottom left;-webkit-mask-repeat:no-repeat;}.number__inner{padding:0 ${tt};transform:scaleX(calc(1 / var(--scale-x))) translateX(calc(-1 * var(${q})));}.section{display:inline-flex;align-items:baseline;padding-bottom:${C};padding-top:${C};position:relative;isolation:isolate;}.section::after{content:'\\200b';display:block;padding:${C} 0;}:host([data-will-change]) .section{will-change:transform;}.section--justify-left{transform-origin:center left;}.section--justify-right{transform-origin:center right;}.section__exiting{position:absolute !important;z-index:-1;}.digit{display:block;position:relative;--c:var(--current) + var(${at});}:host([data-will-change]) .digit,:host([data-will-change]) .digit__num{will-change:transform;}.digit__num{display:block;padding:${C} 0;--offset-raw:mod(10 + var(--n) - mod(var(--c),10),10);--offset:calc(var(--offset-raw) - 10 * round(down,var(--offset-raw) / 5,1));--y:clamp(-100%,var(--offset) * 100%,100%);transform:translateY(var(--y));}.digit__num:not(.is-current){position:absolute;top:0;left:50%;transform:translateX(-50%) translateY(var(--y));}.digit:not(.is-spinning) .digit__num:not(.is-current){display:none;}.symbol{display:inline-flex;align-items:baseline;position:relative;isolation:isolate;padding:${C} 0;}:host([data-will-change]) .symbol{will-change:transform;}.symbol__value{display:block;white-space:pre;}.symbol__exiting{position:absolute;z-index:-1;}.section--justify-left .symbol__exiting{left:0;}.section--justify-right .symbol__exiting{right:0;}.animate-presence{opacity:calc(1 + var(${Z}));}`, vt = F ? HTMLElement : class {\n}, Nt = ({ formatted: a, willChange: t }) => `<${et} style=\"font-kerning: none; display: inline-block; line-height: ${ht}; padding: ${g} 0;${t ? \"will-change: transform\" : \"\"}\">${a}</${et}>`, bt = (a, t) => a != null && t == null ? a : a == null && t != null ? t : a != null && t != null ? Math.max(a, t) : null;\nvar P, B, k, x, $, y, U, L, R, W, H, E, M, V, X, z, j, I, T, A, _, G, it, v, Y, K;\nconst St = yt && wt && _t;\nvar b;\n(function(a) {\n  a[a.UP = 1] = \"UP\", a[a.DOWN = -1] = \"DOWN\", a[a.NONE = 0] = \"NONE\";\n})(b || (b = {}));\nlet O;\nclass kt extends vt {\n  constructor() {\n    super(...arguments), this.transformTiming = this.constructor.defaultProps.transformTiming, this.spinTiming = this.constructor.defaultProps.spinTiming, this.opacityTiming = this.constructor.defaultProps.opacityTiming, this.respectMotionPreference = this.constructor.defaultProps.respectMotionPreference, this.trend = this.constructor.defaultProps.trend, this.continuous = this.constructor.defaultProps.continuous, P.set(this, this.constructor.defaultProps.animated), B.set(this, !1), k.set(this, void 0), x.set(this, void 0), $.set(this, void 0), y.set(this, void 0), U.set(this, void 0), L.set(this, s(this, P, \"f\")), R.set(this, void 0), this.manual = !1, W.set(this, void 0);\n  }\n  get animated() {\n    return s(this, P, \"f\");\n  }\n  set animated(t) {\n    var e;\n    this.animated !== t && (h(this, P, t, \"f\"), (e = this.shadowRoot) == null || e.getAnimations().forEach((i) => i.finish()));\n  }\n  get computedTrend() {\n    return s(this, y, \"f\");\n  }\n  get startingPlace() {\n    return s(this, U, \"f\");\n  }\n  get computedAnimated() {\n    return s(this, L, \"f\");\n  }\n  set parts(t) {\n    if (t == null)\n      return;\n    const { pre: e, integer: i, fraction: n, post: r, value: l } = t;\n    if (s(this, B, \"f\")) {\n      const o = s(this, R, \"f\");\n      if (h(this, R, t, \"f\"), this.trend === !0 ? h(this, y, Math.sign(l - o.value), \"f\") : this.trend === \"increasing\" ? h(this, y, b.UP, \"f\") : this.trend === \"decreasing\" ? h(this, y, b.DOWN, \"f\") : h(this, y, b.NONE, \"f\"), h(this, U, void 0, \"f\"), s(this, y, \"f\") !== b.NONE && this.continuous) {\n        const p = o.integer.concat(o.fraction).filter((d) => d.type === \"integer\" || d.type === \"fraction\"), u = t.integer.concat(t.fraction).filter((d) => d.type === \"integer\" || d.type === \"fraction\"), m = p.find((d) => !u.find((c) => c.place === d.place && c.value === d.value)), N = u.find((d) => !p.find((c) => d.place === c.place && d.value === c.value));\n        h(this, U, bt(m == null ? void 0 : m.place, N == null ? void 0 : N.place), \"f\");\n      }\n      h(this, L, St && s(this, P, \"f\") && (!this.respectMotionPreference || !(Q != null && Q.matches)) && // https://github.com/barvian/number-flow/issues/9\n      ut(this), \"f\"), this.manual || this.willUpdate(), s(this, k, \"f\").update(e), s(this, x, \"f\").update({ integer: i, fraction: n }), s(this, $, \"f\").update(r), this.manual || this.didUpdate();\n    } else {\n      if (h(this, R, t, \"f\"), this.attachShadow({ mode: \"open\" }), typeof CSSStyleSheet < \"u\" && this.shadowRoot.adoptedStyleSheets)\n        O || (O = new CSSStyleSheet(), O.replaceSync(ot)), this.shadowRoot.adoptedStyleSheets = [O];\n      else {\n        const o = document.createElement(\"style\");\n        o.textContent = ot, this.shadowRoot.appendChild(o);\n      }\n      this.shadowRoot.appendChild(w(\"slot\")), h(this, k, new lt(this, e, {\n        inert: !0,\n        ariaHidden: \"true\",\n        justify: \"right\"\n      }), \"f\"), this.shadowRoot.appendChild(s(this, k, \"f\").el), h(this, x, new xt(this, i, n, {\n        inert: !0,\n        ariaHidden: \"true\"\n      }), \"f\"), this.shadowRoot.appendChild(s(this, x, \"f\").el), h(this, $, new lt(this, r, {\n        inert: !0,\n        ariaHidden: \"true\",\n        justify: \"left\"\n      }), \"f\"), this.shadowRoot.appendChild(s(this, $, \"f\").el);\n    }\n    h(this, B, !0, \"f\");\n  }\n  willUpdate() {\n    s(this, k, \"f\").willUpdate(), s(this, x, \"f\").willUpdate(), s(this, $, \"f\").willUpdate();\n  }\n  didUpdate() {\n    if (!s(this, L, \"f\"))\n      return;\n    s(this, W, \"f\") ? s(this, W, \"f\").abort() : this.dispatchEvent(new Event(\"animationsstart\")), s(this, k, \"f\").didUpdate(), s(this, x, \"f\").didUpdate(), s(this, $, \"f\").didUpdate();\n    const t = new AbortController();\n    Promise.all(this.shadowRoot.getAnimations().map((e) => e.finished)).then(() => {\n      t.signal.aborted || (this.dispatchEvent(new Event(\"animationsfinish\")), h(this, W, void 0, \"f\"));\n    }), h(this, W, t, \"f\");\n  }\n}\nP = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), $ = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap();\nkt.defaultProps = {\n  transformTiming: {\n    duration: 900,\n    // Make sure to keep this minified:\n    easing: \"linear(0,.005,.019,.039,.066,.096,.129,.165,.202,.24,.278,.316,.354,.39,.426,.461,.494,.526,.557,.586,.614,.64,.665,.689,.711,.731,.751,.769,.786,.802,.817,.831,.844,.856,.867,.877,.887,.896,.904,.912,.919,.925,.931,.937,.942,.947,.951,.955,.959,.962,.965,.968,.971,.973,.976,.978,.98,.981,.983,.984,.986,.987,.988,.989,.99,.991,.992,.992,.993,.994,.994,.995,.995,.996,.996,.9963,.9967,.9969,.9972,.9975,.9977,.9979,.9981,.9982,.9984,.9985,.9987,.9988,.9989,1)\"\n  },\n  spinTiming: void 0,\n  opacityTiming: { duration: 450, easing: \"ease-out\" },\n  animated: !0,\n  trend: !0,\n  continuous: !1,\n  respectMotionPreference: !0\n};\nclass xt {\n  constructor(t, e, i, { className: n, ...r } = {}) {\n    this.flow = t, H.set(this, void 0), E.set(this, void 0), M.set(this, void 0), V.set(this, void 0), X.set(this, void 0), h(this, E, new rt(t, e, {\n      justify: \"right\"\n    }), \"f\"), h(this, M, new rt(t, i, {\n      justify: \"left\"\n    }), \"f\"), h(this, H, w(\"span\", {\n      className: \"number__inner\"\n    }, [s(this, E, \"f\").el, s(this, M, \"f\").el]), \"f\"), this.el = w(\"span\", {\n      ...r,\n      className: `number ${n ?? \"\"}`\n    }, [s(this, H, \"f\")]);\n  }\n  willUpdate() {\n    h(this, V, this.el.offsetWidth, \"f\"), h(this, X, this.el.getBoundingClientRect().left, \"f\"), s(this, E, \"f\").willUpdate(), s(this, M, \"f\").willUpdate();\n  }\n  update({ integer: t, fraction: e }) {\n    s(this, E, \"f\").update(t), s(this, M, \"f\").update(e);\n  }\n  didUpdate() {\n    const t = this.el.getBoundingClientRect();\n    s(this, E, \"f\").didUpdate(), s(this, M, \"f\").didUpdate();\n    const e = s(this, X, \"f\") - t.left, i = this.el.offsetWidth, n = s(this, V, \"f\") - i;\n    this.el.style.setProperty(\"--width\", String(i)), this.el.animate({\n      [q]: [`${e}px`, \"0px\"],\n      [nt]: [n, 0]\n    }, {\n      ...this.flow.transformTiming,\n      composite: \"accumulate\"\n    });\n  }\n}\nH = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap();\nclass ct {\n  constructor(t, e, { justify: i, className: n, ...r }, l) {\n    this.flow = t, this.children = /* @__PURE__ */ new Map(), this.onCharRemove = (p) => () => {\n      this.children.delete(p);\n    }, z.set(this, void 0), this.justify = i;\n    const o = e.map((p) => this.addChar(p).el);\n    this.el = w(\"span\", {\n      ...r,\n      className: `section section--justify-${i} ${n ?? \"\"}`\n    }, l ? l(o) : o);\n  }\n  addChar(t, { startDigitsAtZero: e = !1, ...i } = {}) {\n    const n = t.type === \"integer\" || t.type === \"fraction\" ? new dt(this, t.type, e ? 0 : t.value, t.place, {\n      ...i,\n      onRemove: this.onCharRemove(t.key)\n    }) : new $t(this, t.type, t.value, {\n      ...i,\n      onRemove: this.onCharRemove(t.key)\n    });\n    return this.children.set(t.key, n), n;\n  }\n  unpop(t) {\n    t.el.classList.remove(\"section__exiting\"), t.el.style[this.justify] = \"\";\n  }\n  pop(t) {\n    t.forEach((e) => {\n      e.el.style[this.justify] = `${pt(e.el, this.justify)}px`;\n    }), t.forEach((e) => {\n      e.el.classList.add(\"section__exiting\"), e.present = !1;\n    });\n  }\n  addNewAndUpdateExisting(t) {\n    const e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = this.justify === \"left\", r = n ? \"prepend\" : \"append\";\n    if (mt(t, (l) => {\n      let o;\n      this.children.has(l.key) ? (o = this.children.get(l.key), i.set(l, o), this.unpop(o), o.present = !0) : (o = this.addChar(l, { startDigitsAtZero: !0, animateIn: !0 }), e.set(l, o)), this.el[r](o.el);\n    }, { reverse: n }), this.flow.computedAnimated) {\n      const l = this.el.getBoundingClientRect();\n      e.forEach((o) => {\n        o.willUpdate(l);\n      });\n    }\n    e.forEach((l, o) => {\n      l.update(o.value);\n    }), i.forEach((l, o) => {\n      l.update(o.value);\n    });\n  }\n  willUpdate() {\n    const t = this.el.getBoundingClientRect();\n    h(this, z, t[this.justify], \"f\"), this.children.forEach((e) => e.willUpdate(t));\n  }\n  didUpdate() {\n    const t = this.el.getBoundingClientRect();\n    this.children.forEach((n) => n.didUpdate(t));\n    const e = t[this.justify], i = s(this, z, \"f\") - e;\n    this.el.animate({\n      transform: [`translateX(${i}px)`, \"none\"]\n    }, {\n      ...this.flow.transformTiming,\n      composite: \"accumulate\"\n    });\n  }\n}\nz = /* @__PURE__ */ new WeakMap();\nclass rt extends ct {\n  update(t) {\n    const e = /* @__PURE__ */ new Map();\n    this.children.forEach((i, n) => {\n      t.find((r) => r.key === n) || e.set(n, i), this.unpop(i);\n    }), this.addNewAndUpdateExisting(t), e.forEach((i) => {\n      i instanceof dt && i.update(0);\n    }), this.pop(e);\n  }\n}\nclass lt extends ct {\n  update(t) {\n    const e = /* @__PURE__ */ new Map();\n    this.children.forEach((i, n) => {\n      t.find((r) => r.key === n) || e.set(n, i);\n    }), this.pop(e), this.addNewAndUpdateExisting(t);\n  }\n}\nclass st {\n  constructor(t, e, { onRemove: i, animateIn: n = !1 } = {}) {\n    this.flow = t, this.el = e, j.set(this, !0), I.set(this, void 0), T.set(this, () => {\n      var r;\n      this.el.remove(), (r = s(this, I, \"f\")) == null || r.call(this);\n    }), this.el.classList.add(\"animate-presence\"), this.flow.computedAnimated && n && this.el.animate({\n      [Z]: [-0.9999, 0]\n    }, {\n      ...this.flow.opacityTiming,\n      composite: \"accumulate\"\n    }), h(this, I, i, \"f\");\n  }\n  get present() {\n    return s(this, j, \"f\");\n  }\n  set present(t) {\n    if (s(this, j, \"f\") !== t) {\n      if (h(this, j, t, \"f\"), !this.flow.computedAnimated) {\n        t || s(this, T, \"f\").call(this);\n        return;\n      }\n      this.el.style.setProperty(\"--_number-flow-d-opacity\", t ? \"0\" : \"-.999\"), this.el.animate({\n        [Z]: t ? [-0.9999, 0] : [0.999, 0]\n      }, {\n        ...this.flow.opacityTiming,\n        composite: \"accumulate\"\n      }), t ? this.flow.removeEventListener(\"animationsfinish\", s(this, T, \"f\")) : this.flow.addEventListener(\"animationsfinish\", s(this, T, \"f\"), {\n        once: !0\n      });\n    }\n  }\n}\nj = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap();\nclass ft extends st {\n  constructor(t, e, i, n) {\n    super(t.flow, i, n), this.section = t, this.value = e, this.el = i;\n  }\n}\nclass dt extends ft {\n  constructor(t, e, i, n, r) {\n    const l = Array.from({ length: 10 }).map((p, u) => {\n      const m = w(\"span\", { className: `digit__num${u === i ? \" is-current\" : \"\"}` }, [document.createTextNode(String(u))]);\n      return m.style.setProperty(\"--n\", String(u)), m;\n    }), o = w(\"span\", {\n      className: \"digit\"\n    }, l);\n    o.style.setProperty(\"--current\", String(i)), super(t, i, o, r), this.place = n, A.set(this, void 0), _.set(this, void 0), G.set(this, void 0), it.set(this, () => {\n      this.el.classList.remove(\"is-spinning\");\n    }), h(this, A, l, \"f\");\n  }\n  willUpdate(t) {\n    const e = this.el.getBoundingClientRect();\n    h(this, _, this.value, \"f\");\n    const i = e[this.section.justify] - t[this.section.justify], n = e.width / 2;\n    h(this, G, this.section.justify === \"left\" ? i + n : i - n, \"f\");\n  }\n  update(t) {\n    var e, i;\n    (e = s(this, A, \"f\")[this.value]) == null || e.classList.remove(\"is-current\"), this.el.style.setProperty(\"--current\", String(t)), (i = s(this, A, \"f\")[t]) == null || i.classList.add(\"is-current\"), this.value = t;\n  }\n  didUpdate(t) {\n    const e = this.el.getBoundingClientRect(), i = e[this.section.justify] - t[this.section.justify], n = e.width / 2, r = this.section.justify === \"left\" ? i + n : i - n;\n    this.el.animate({\n      transform: [`translateX(${s(this, G, \"f\") - r}px)`, \"none\"]\n    }, {\n      ...this.flow.transformTiming,\n      composite: \"accumulate\"\n    });\n    const l = this.diff;\n    l && (this.el.classList.add(\"is-spinning\"), this.el.animate({\n      [at]: [-l, 0]\n    }, {\n      ...this.flow.spinTiming ?? this.flow.transformTiming,\n      composite: \"accumulate\"\n    }), this.flow.addEventListener(\"animationsfinish\", s(this, it, \"f\"), { once: !0 }));\n  }\n  get diff() {\n    let t = this.flow.computedTrend;\n    const e = this.value - s(this, _, \"f\");\n    return !e && this.flow.startingPlace != null && this.flow.startingPlace >= this.place ? 10 * t : (t || (t = Math.sign(e)), t === b.DOWN && this.value > s(this, _, \"f\") ? this.value - 10 - s(this, _, \"f\") : t === b.UP && this.value < s(this, _, \"f\") ? 10 - s(this, _, \"f\") + this.value : e);\n  }\n}\nA = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap();\nclass $t extends ft {\n  constructor(t, e, i, n) {\n    const r = w(\"span\", {\n      className: \"symbol__value\",\n      textContent: i\n    });\n    super(t, i, w(\"span\", {\n      className: \"symbol\"\n    }, [r]), n), this.type = e, v.set(this, /* @__PURE__ */ new Map()), Y.set(this, void 0), K.set(this, (l) => () => {\n      s(this, v, \"f\").delete(l);\n    }), s(this, v, \"f\").set(i, new st(this.flow, r, {\n      onRemove: s(this, K, \"f\").call(this, i)\n    }));\n  }\n  willUpdate(t) {\n    if (this.type === \"decimal\")\n      return;\n    const e = this.el.getBoundingClientRect();\n    h(this, Y, e[this.section.justify] - t[this.section.justify], \"f\");\n  }\n  update(t) {\n    if (this.value !== t) {\n      const e = s(this, v, \"f\").get(this.value);\n      if (e.present = !1, e.el.classList.add(\"symbol__exiting\"), s(this, v, \"f\").has(t)) {\n        const i = s(this, v, \"f\").get(t);\n        i.present = !0, i.el.classList.remove(\"symbol__exiting\");\n      } else {\n        const i = w(\"span\", {\n          className: \"symbol__value\",\n          textContent: t\n        });\n        this.el.appendChild(i), s(this, v, \"f\").set(t, new st(this.flow, i, {\n          animateIn: !0,\n          onRemove: s(this, K, \"f\").call(this, t)\n        }));\n      }\n    }\n    this.value = t;\n  }\n  didUpdate(t) {\n    if (this.type === \"decimal\")\n      return;\n    const i = this.el.getBoundingClientRect()[this.section.justify] - t[this.section.justify];\n    this.el.animate({\n      transform: [`translateX(${s(this, Y, \"f\") - i}px)`, \"none\"]\n    }, { ...this.flow.transformTiming, composite: \"accumulate\" });\n  }\n}\nv = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWZsb3cvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsSUFBSTtBQUMxQztBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsY0FBYyxFQUFFLEdBQUcsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDZCQUE2QixnQ0FBZ0MseUJBQXlCLHdDQUF3QyxvQ0FBb0M7QUFDM087QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUMsMkdBQTJHLEdBQUcsZ0VBQWdFLElBQUksOEVBQThFLG9CQUFvQixxQkFBcUIsY0FBYyxtQkFBbUIsa0JBQWtCLGNBQWMsSUFBSSxXQUFXLG1CQUFtQixZQUFZLEdBQUcsRUFBRSxrQkFBa0IsT0FBTyxNQUFNLDZCQUE2Qiw2QkFBNkIsWUFBWSxpQ0FBaUMsb0JBQW9CLGtCQUFrQix1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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLHNFQUFzRSxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELEtBQUssSUFBSSx1REFBdUQ7QUFDaEU7QUFDQTtBQUNBO0FBUUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NoYnVja2xleS9Eb2N1bWVudHMvY2l0ZWx5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9udW1iZXItZmxvdy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzKGEsIHQsIGUsIGkpIHtcbiAgaWYgKGUgPT09IFwiYVwiICYmICFpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gYSAhPT0gdCB8fCAhaSA6ICF0LmhhcyhhKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGUgPT09IFwibVwiID8gaSA6IGUgPT09IFwiYVwiID8gaS5jYWxsKGEpIDogaSA/IGkudmFsdWUgOiB0LmdldChhKTtcbn1cbmZ1bmN0aW9uIGgoYSwgdCwgZSwgaSwgbikge1xuICBpZiAoaSA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChpID09PSBcImFcIiAmJiAhbikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IGEgIT09IHQgfHwgIW4gOiAhdC5oYXMoYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGkgPT09IFwiYVwiID8gbi5jYWxsKGEsIGUpIDogbiA/IG4udmFsdWUgPSBlIDogdC5zZXQoYSwgZSksIGU7XG59XG5jb25zdCBGID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiLCB3ID0gKGEsIHQsIGUpID0+IHtcbiAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYSksIFtuLCByXSA9IEFycmF5LmlzQXJyYXkodCkgPyBbdm9pZCAwLCB0XSA6IFt0LCBlXTtcbiAgcmV0dXJuIG4gJiYgT2JqZWN0LmFzc2lnbihpLCBuKSwgciA9PSBudWxsIHx8IHIuZm9yRWFjaCgobCkgPT4gaS5hcHBlbmRDaGlsZChsKSksIGk7XG59LCBwdCA9IChhLCB0KSA9PiB7XG4gIHZhciBlO1xuICByZXR1cm4gdCA9PT0gXCJsZWZ0XCIgPyBhLm9mZnNldExlZnQgOiAoKChlID0gYS5vZmZzZXRQYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IGEub2Zmc2V0UGFyZW50IDogbnVsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUub2Zmc2V0V2lkdGgpID8/IDApIC0gYS5vZmZzZXRXaWR0aCAtIGEub2Zmc2V0TGVmdDtcbn0sIHV0ID0gKGEpID0+IGEub2Zmc2V0V2lkdGggPiAwICYmIGEub2Zmc2V0SGVpZ2h0ID4gMCwgRXQgPSAoYSwgdCkgPT4ge1xuICBpZiAoISghRiB8fCBjdXN0b21FbGVtZW50cy5nZXQoYSkgPT09IHQpKVxuICAgIHJldHVybiBjdXN0b21FbGVtZW50cy5kZWZpbmUoYSwgdCk7XG59O1xuZnVuY3Rpb24gbXQoYSwgdCwgeyByZXZlcnNlOiBlID0gITEgfSA9IHt9KSB7XG4gIGNvbnN0IGkgPSBhLmxlbmd0aDtcbiAgZm9yIChsZXQgbiA9IGUgPyBpIC0gMSA6IDA7IGUgPyBuID49IDAgOiBuIDwgaTsgZSA/IG4tLSA6IG4rKylcbiAgICB0KGFbbl0sIG4pO1xufVxuZnVuY3Rpb24gTXQoYSwgdCkge1xuICBjb25zdCBlID0gdC5mb3JtYXRUb1BhcnRzKGEpLCBpID0gW10sIG4gPSBbXSwgciA9IFtdLCBsID0gW10sIG8gPSB7fSwgcCA9IChjKSA9PiB7XG4gICAgY29uc3QgZiA9IG9bY10gPT0gbnVsbCA/IG9bY10gPSAwIDogKytvW2NdO1xuICAgIHJldHVybiBgJHtjfToke2Z9YDtcbiAgfTtcbiAgbGV0IHUgPSBcIlwiLCBtID0gITEsIE4gPSAhMTtcbiAgZm9yIChjb25zdCBjIG9mIGUpIHtcbiAgICB1ICs9IGMudmFsdWU7XG4gICAgY29uc3QgZiA9IGMudHlwZSA9PT0gXCJtaW51c1NpZ25cIiB8fCBjLnR5cGUgPT09IFwicGx1c1NpZ25cIiA/IFwic2lnblwiIDogYy50eXBlO1xuICAgIGYgPT09IFwiaW50ZWdlclwiID8gKG0gPSAhMCwgbi5wdXNoKC4uLmMudmFsdWUuc3BsaXQoXCJcIikubWFwKChKKSA9PiAoeyB0eXBlOiBmLCB2YWx1ZTogcGFyc2VJbnQoSikgfSkpKSkgOiBmID09PSBcImdyb3VwXCIgPyBuLnB1c2goeyB0eXBlOiBmLCB2YWx1ZTogYy52YWx1ZSB9KSA6IGYgPT09IFwiZGVjaW1hbFwiID8gKE4gPSAhMCwgci5wdXNoKHsgdHlwZTogZiwgdmFsdWU6IGMudmFsdWUsIGtleTogcChmKSB9KSkgOiBmID09PSBcImZyYWN0aW9uXCIgPyByLnB1c2goLi4uYy52YWx1ZS5zcGxpdChcIlwiKS5tYXAoKEopID0+ICh7XG4gICAgICB0eXBlOiBmLFxuICAgICAgdmFsdWU6IHBhcnNlSW50KEopLFxuICAgICAga2V5OiBwKGYpLFxuICAgICAgcGxhY2U6IC0xIC0gb1tmXVxuICAgIH0pKSkgOiAobSB8fCBOID8gbCA6IGkpLnB1c2goe1xuICAgICAgdHlwZTogZixcbiAgICAgIHZhbHVlOiBjLnZhbHVlLFxuICAgICAga2V5OiBwKGYpXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZCA9IFtdO1xuICBmb3IgKGxldCBjID0gbi5sZW5ndGggLSAxOyBjID49IDA7IGMtLSkge1xuICAgIGNvbnN0IGYgPSBuW2NdO1xuICAgIGQudW5zaGlmdChmLnR5cGUgPT09IFwiaW50ZWdlclwiID8ge1xuICAgICAgLi4uZixcbiAgICAgIGtleTogcChmLnR5cGUpLFxuICAgICAgcGxhY2U6IG9bZi50eXBlXVxuICAgIH0gOiB7XG4gICAgICAuLi5mLFxuICAgICAga2V5OiBwKGYudHlwZSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByZTogaSxcbiAgICBpbnRlZ2VyOiBkLFxuICAgIGZyYWN0aW9uOiByLFxuICAgIHBvc3Q6IGwsXG4gICAgZm9ybWF0dGVkOiB1LFxuICAgIHZhbHVlOiB0eXBlb2YgYSA9PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdChhKSA6IGFcbiAgfTtcbn1cbmNvbnN0IGd0ID0gU3RyaW5nLnJhdywgd3QgPSBGICYmIHR5cGVvZiBDU1MgPCBcInVcIiAmJiBDU1Muc3VwcG9ydHMoXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsIFwibGluZWFyKDEsMilcIiksIHl0ID0gRiAmJiB0eXBlb2YgQ1NTIDwgXCJ1XCIgJiYgQ1NTLnN1cHBvcnRzKFwibGluZS1oZWlnaHRcIiwgXCJtb2QoMSwxKVwiKSwgUSA9IEYgPyBtYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikgOiBudWxsLCBaID0gXCItLV9udW1iZXItZmxvdy1kLW9wYWNpdHlcIiwgbnQgPSBcIi0tX251bWJlci1mbG93LWQtd2lkdGhcIiwgcSA9IFwiLS1fbnVtYmVyLWZsb3ctZHhcIiwgYXQgPSBcIi0tX251bWJlci1mbG93LWRcIiwgX3QgPSAoKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiBaLFxuICAgICAgc3ludGF4OiBcIjxudW1iZXI+XCIsXG4gICAgICBpbmhlcml0czogITEsXG4gICAgICBpbml0aWFsVmFsdWU6IFwiMFwiXG4gICAgfSksIENTUy5yZWdpc3RlclByb3BlcnR5KHtcbiAgICAgIG5hbWU6IHEsXG4gICAgICBzeW50YXg6IFwiPGxlbmd0aD5cIixcbiAgICAgIGluaGVyaXRzOiAhMCxcbiAgICAgIGluaXRpYWxWYWx1ZTogXCIwcHhcIlxuICAgIH0pLCBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiBudCxcbiAgICAgIHN5bnRheDogXCI8bnVtYmVyPlwiLFxuICAgICAgaW5oZXJpdHM6ICExLFxuICAgICAgaW5pdGlhbFZhbHVlOiBcIjBcIlxuICAgIH0pLCBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiBhdCxcbiAgICAgIHN5bnRheDogXCI8bnVtYmVyPlwiLFxuICAgICAgaW5oZXJpdHM6ICEwLFxuICAgICAgaW5pdGlhbFZhbHVlOiBcIjBcIlxuICAgIH0pLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59KSgpLCBodCA9IFwidmFyKC0tbnVtYmVyLWZsb3ctY2hhci1oZWlnaHQsIDFlbSlcIiwgZyA9IFwidmFyKC0tbnVtYmVyLWZsb3ctbWFzay1oZWlnaHQsIDAuMjVlbSlcIiwgQyA9IGBjYWxjKCR7Z30gLyAyKWAsIHR0ID0gXCJ2YXIoLS1udW1iZXItZmxvdy1tYXNrLXdpZHRoLCAwLjVlbSlcIiwgUyA9IGBjYWxjKCR7dHR9IC8gdmFyKC0tc2NhbGUteCkpYCwgRCA9IFwiIzAwMCAwLCB0cmFuc3BhcmVudCA3MSVcIiwgZXQgPSBcInNwYW5cIiwgb3QgPSBndGA6aG9zdHtkaXNwbGF5OmlubGluZS1mbGV4O2FsaWduLWl0ZW1zOmJhc2VsaW5lO2RpcmVjdGlvbjpsdHI7d2hpdGUtc3BhY2U6bm93cmFwO3Bvc2l0aW9uOnJlbGF0aXZlO2xpbmUtaGVpZ2h0OiR7aHR9ICFpbXBvcnRhbnQ7aXNvbGF0aW9uOmlzb2xhdGU7fTo6c2xvdHRlZCgke2V0fSl7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO2NvbG9yOnRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7d2lsbC1jaGFuZ2U6dW5zZXQgIWltcG9ydGFudDt6LWluZGV4Oi01O306aG9zdCA+IC5udW1iZXIsOmhvc3QgPiAuc2VjdGlvbntwb2ludGVyLWV2ZW50czpub25lO3VzZXItc2VsZWN0Om5vbmU7fS5udW1iZXIsLm51bWJlcl9faW5uZXJ7ZGlzcGxheTppbmxpbmUtZmxleDthbGlnbi1pdGVtczpiYXNlbGluZTt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wO306aG9zdChbZGF0YS13aWxsLWNoYW5nZV0pIC5udW1iZXIsOmhvc3QoW2RhdGEtd2lsbC1jaGFuZ2VdKSAubnVtYmVyX19pbm5lcnt3aWxsLWNoYW5nZTp0cmFuc2Zvcm07fS5udW1iZXJ7LS1zY2FsZS14OmNhbGMoMSArIHZhcigke250fSkgLyB2YXIoLS13aWR0aCkpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKHZhcigke3F9KSkgc2NhbGVYKHZhcigtLXNjYWxlLXgpKTttYXJnaW46MCBjYWxjKC0xICogJHt0dH0pO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6LTE7b3ZlcmZsb3c6Y2xpcDstd2Via2l0LW1hc2staW1hZ2U6bGluZWFyLWdyYWRpZW50KCB0byByaWdodCx0cmFuc3BhcmVudCAwLCMwMDAgJHtTfSwjMDAwIGNhbGMoMTAwJSAtICR7U30pLHRyYW5zcGFyZW50ICksbGluZWFyLWdyYWRpZW50KCB0byBib3R0b20sdHJhbnNwYXJlbnQgMCwjMDAwICR7Z30sIzAwMCBjYWxjKDEwMCUgLSAke2d9KSx0cmFuc3BhcmVudCAxMDAlICkscmFkaWFsLWdyYWRpZW50KGF0IGJvdHRvbSByaWdodCwke0R9KSxyYWRpYWwtZ3JhZGllbnQoYXQgYm90dG9tIGxlZnQsJHtEfSkscmFkaWFsLWdyYWRpZW50KGF0IHRvcCBsZWZ0LCR7RH0pLHJhZGlhbC1ncmFkaWVudChhdCB0b3AgcmlnaHQsJHtEfSk7LXdlYmtpdC1tYXNrLXNpemU6MTAwJSBjYWxjKDEwMCUgLSAke2d9ICogMiksY2FsYygxMDAlIC0gJHtTfSAqIDIpIDEwMCUsJHtTfSAke2d9LCR7U30gJHtnfSwke1N9ICR7Z30sJHtTfSAke2d9Oy13ZWJraXQtbWFzay1wb3NpdGlvbjpjZW50ZXIsY2VudGVyLHRvcCBsZWZ0LHRvcCByaWdodCxib3R0b20gcmlnaHQsYm90dG9tIGxlZnQ7LXdlYmtpdC1tYXNrLXJlcGVhdDpuby1yZXBlYXQ7fS5udW1iZXJfX2lubmVye3BhZGRpbmc6MCAke3R0fTt0cmFuc2Zvcm06c2NhbGVYKGNhbGMoMSAvIHZhcigtLXNjYWxlLXgpKSkgdHJhbnNsYXRlWChjYWxjKC0xICogdmFyKCR7cX0pKSk7fS5zZWN0aW9ue2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6YmFzZWxpbmU7cGFkZGluZy1ib3R0b206JHtDfTtwYWRkaW5nLXRvcDoke0N9O3Bvc2l0aW9uOnJlbGF0aXZlO2lzb2xhdGlvbjppc29sYXRlO30uc2VjdGlvbjo6YWZ0ZXJ7Y29udGVudDonXFwyMDBiJztkaXNwbGF5OmJsb2NrO3BhZGRpbmc6JHtDfSAwO306aG9zdChbZGF0YS13aWxsLWNoYW5nZV0pIC5zZWN0aW9ue3dpbGwtY2hhbmdlOnRyYW5zZm9ybTt9LnNlY3Rpb24tLWp1c3RpZnktbGVmdHt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBsZWZ0O30uc2VjdGlvbi0tanVzdGlmeS1yaWdodHt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciByaWdodDt9LnNlY3Rpb25fX2V4aXRpbmd7cG9zaXRpb246YWJzb2x1dGUgIWltcG9ydGFudDt6LWluZGV4Oi0xO30uZGlnaXR7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTstLWM6dmFyKC0tY3VycmVudCkgKyB2YXIoJHthdH0pO306aG9zdChbZGF0YS13aWxsLWNoYW5nZV0pIC5kaWdpdCw6aG9zdChbZGF0YS13aWxsLWNoYW5nZV0pIC5kaWdpdF9fbnVte3dpbGwtY2hhbmdlOnRyYW5zZm9ybTt9LmRpZ2l0X19udW17ZGlzcGxheTpibG9jaztwYWRkaW5nOiR7Q30gMDstLW9mZnNldC1yYXc6bW9kKDEwICsgdmFyKC0tbikgLSBtb2QodmFyKC0tYyksMTApLDEwKTstLW9mZnNldDpjYWxjKHZhcigtLW9mZnNldC1yYXcpIC0gMTAgKiByb3VuZChkb3duLHZhcigtLW9mZnNldC1yYXcpIC8gNSwxKSk7LS15OmNsYW1wKC0xMDAlLHZhcigtLW9mZnNldCkgKiAxMDAlLDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKHZhcigtLXkpKTt9LmRpZ2l0X19udW06bm90KC5pcy1jdXJyZW50KXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKHZhcigtLXkpKTt9LmRpZ2l0Om5vdCguaXMtc3Bpbm5pbmcpIC5kaWdpdF9fbnVtOm5vdCguaXMtY3VycmVudCl7ZGlzcGxheTpub25lO30uc3ltYm9se2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6YmFzZWxpbmU7cG9zaXRpb246cmVsYXRpdmU7aXNvbGF0aW9uOmlzb2xhdGU7cGFkZGluZzoke0N9IDA7fTpob3N0KFtkYXRhLXdpbGwtY2hhbmdlXSkgLnN5bWJvbHt3aWxsLWNoYW5nZTp0cmFuc2Zvcm07fS5zeW1ib2xfX3ZhbHVle2Rpc3BsYXk6YmxvY2s7d2hpdGUtc3BhY2U6cHJlO30uc3ltYm9sX19leGl0aW5ne3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6LTE7fS5zZWN0aW9uLS1qdXN0aWZ5LWxlZnQgLnN5bWJvbF9fZXhpdGluZ3tsZWZ0OjA7fS5zZWN0aW9uLS1qdXN0aWZ5LXJpZ2h0IC5zeW1ib2xfX2V4aXRpbmd7cmlnaHQ6MDt9LmFuaW1hdGUtcHJlc2VuY2V7b3BhY2l0eTpjYWxjKDEgKyB2YXIoJHtafSkpO31gLCB2dCA9IEYgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn0sIE50ID0gKHsgZm9ybWF0dGVkOiBhLCB3aWxsQ2hhbmdlOiB0IH0pID0+IGA8JHtldH0gc3R5bGU9XCJmb250LWtlcm5pbmc6IG5vbmU7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgbGluZS1oZWlnaHQ6ICR7aHR9OyBwYWRkaW5nOiAke2d9IDA7JHt0ID8gXCJ3aWxsLWNoYW5nZTogdHJhbnNmb3JtXCIgOiBcIlwifVwiPiR7YX08LyR7ZXR9PmAsIGJ0ID0gKGEsIHQpID0+IGEgIT0gbnVsbCAmJiB0ID09IG51bGwgPyBhIDogYSA9PSBudWxsICYmIHQgIT0gbnVsbCA/IHQgOiBhICE9IG51bGwgJiYgdCAhPSBudWxsID8gTWF0aC5tYXgoYSwgdCkgOiBudWxsO1xudmFyIFAsIEIsIGssIHgsICQsIHksIFUsIEwsIFIsIFcsIEgsIEUsIE0sIFYsIFgsIHosIGosIEksIFQsIEEsIF8sIEcsIGl0LCB2LCBZLCBLO1xuY29uc3QgU3QgPSB5dCAmJiB3dCAmJiBfdDtcbnZhciBiO1xuKGZ1bmN0aW9uKGEpIHtcbiAgYVthLlVQID0gMV0gPSBcIlVQXCIsIGFbYS5ET1dOID0gLTFdID0gXCJET1dOXCIsIGFbYS5OT05FID0gMF0gPSBcIk5PTkVcIjtcbn0pKGIgfHwgKGIgPSB7fSkpO1xubGV0IE87XG5jbGFzcyBrdCBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50cmFuc2Zvcm1UaW1pbmcgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcy50cmFuc2Zvcm1UaW1pbmcsIHRoaXMuc3BpblRpbWluZyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzLnNwaW5UaW1pbmcsIHRoaXMub3BhY2l0eVRpbWluZyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzLm9wYWNpdHlUaW1pbmcsIHRoaXMucmVzcGVjdE1vdGlvblByZWZlcmVuY2UgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcy5yZXNwZWN0TW90aW9uUHJlZmVyZW5jZSwgdGhpcy50cmVuZCA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzLnRyZW5kLCB0aGlzLmNvbnRpbnVvdXMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcy5jb250aW51b3VzLCBQLnNldCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcy5hbmltYXRlZCksIEIuc2V0KHRoaXMsICExKSwgay5zZXQodGhpcywgdm9pZCAwKSwgeC5zZXQodGhpcywgdm9pZCAwKSwgJC5zZXQodGhpcywgdm9pZCAwKSwgeS5zZXQodGhpcywgdm9pZCAwKSwgVS5zZXQodGhpcywgdm9pZCAwKSwgTC5zZXQodGhpcywgcyh0aGlzLCBQLCBcImZcIikpLCBSLnNldCh0aGlzLCB2b2lkIDApLCB0aGlzLm1hbnVhbCA9ICExLCBXLnNldCh0aGlzLCB2b2lkIDApO1xuICB9XG4gIGdldCBhbmltYXRlZCgpIHtcbiAgICByZXR1cm4gcyh0aGlzLCBQLCBcImZcIik7XG4gIH1cbiAgc2V0IGFuaW1hdGVkKHQpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLmFuaW1hdGVkICE9PSB0ICYmIChoKHRoaXMsIFAsIHQsIFwiZlwiKSwgKGUgPSB0aGlzLnNoYWRvd1Jvb3QpID09IG51bGwgfHwgZS5nZXRBbmltYXRpb25zKCkuZm9yRWFjaCgoaSkgPT4gaS5maW5pc2goKSkpO1xuICB9XG4gIGdldCBjb21wdXRlZFRyZW5kKCkge1xuICAgIHJldHVybiBzKHRoaXMsIHksIFwiZlwiKTtcbiAgfVxuICBnZXQgc3RhcnRpbmdQbGFjZSgpIHtcbiAgICByZXR1cm4gcyh0aGlzLCBVLCBcImZcIik7XG4gIH1cbiAgZ2V0IGNvbXB1dGVkQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHModGhpcywgTCwgXCJmXCIpO1xuICB9XG4gIHNldCBwYXJ0cyh0KSB7XG4gICAgaWYgKHQgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHByZTogZSwgaW50ZWdlcjogaSwgZnJhY3Rpb246IG4sIHBvc3Q6IHIsIHZhbHVlOiBsIH0gPSB0O1xuICAgIGlmIChzKHRoaXMsIEIsIFwiZlwiKSkge1xuICAgICAgY29uc3QgbyA9IHModGhpcywgUiwgXCJmXCIpO1xuICAgICAgaWYgKGgodGhpcywgUiwgdCwgXCJmXCIpLCB0aGlzLnRyZW5kID09PSAhMCA/IGgodGhpcywgeSwgTWF0aC5zaWduKGwgLSBvLnZhbHVlKSwgXCJmXCIpIDogdGhpcy50cmVuZCA9PT0gXCJpbmNyZWFzaW5nXCIgPyBoKHRoaXMsIHksIGIuVVAsIFwiZlwiKSA6IHRoaXMudHJlbmQgPT09IFwiZGVjcmVhc2luZ1wiID8gaCh0aGlzLCB5LCBiLkRPV04sIFwiZlwiKSA6IGgodGhpcywgeSwgYi5OT05FLCBcImZcIiksIGgodGhpcywgVSwgdm9pZCAwLCBcImZcIiksIHModGhpcywgeSwgXCJmXCIpICE9PSBiLk5PTkUgJiYgdGhpcy5jb250aW51b3VzKSB7XG4gICAgICAgIGNvbnN0IHAgPSBvLmludGVnZXIuY29uY2F0KG8uZnJhY3Rpb24pLmZpbHRlcigoZCkgPT4gZC50eXBlID09PSBcImludGVnZXJcIiB8fCBkLnR5cGUgPT09IFwiZnJhY3Rpb25cIiksIHUgPSB0LmludGVnZXIuY29uY2F0KHQuZnJhY3Rpb24pLmZpbHRlcigoZCkgPT4gZC50eXBlID09PSBcImludGVnZXJcIiB8fCBkLnR5cGUgPT09IFwiZnJhY3Rpb25cIiksIG0gPSBwLmZpbmQoKGQpID0+ICF1LmZpbmQoKGMpID0+IGMucGxhY2UgPT09IGQucGxhY2UgJiYgYy52YWx1ZSA9PT0gZC52YWx1ZSkpLCBOID0gdS5maW5kKChkKSA9PiAhcC5maW5kKChjKSA9PiBkLnBsYWNlID09PSBjLnBsYWNlICYmIGQudmFsdWUgPT09IGMudmFsdWUpKTtcbiAgICAgICAgaCh0aGlzLCBVLCBidChtID09IG51bGwgPyB2b2lkIDAgOiBtLnBsYWNlLCBOID09IG51bGwgPyB2b2lkIDAgOiBOLnBsYWNlKSwgXCJmXCIpO1xuICAgICAgfVxuICAgICAgaCh0aGlzLCBMLCBTdCAmJiBzKHRoaXMsIFAsIFwiZlwiKSAmJiAoIXRoaXMucmVzcGVjdE1vdGlvblByZWZlcmVuY2UgfHwgIShRICE9IG51bGwgJiYgUS5tYXRjaGVzKSkgJiYgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhcnZpYW4vbnVtYmVyLWZsb3cvaXNzdWVzLzlcbiAgICAgIHV0KHRoaXMpLCBcImZcIiksIHRoaXMubWFudWFsIHx8IHRoaXMud2lsbFVwZGF0ZSgpLCBzKHRoaXMsIGssIFwiZlwiKS51cGRhdGUoZSksIHModGhpcywgeCwgXCJmXCIpLnVwZGF0ZSh7IGludGVnZXI6IGksIGZyYWN0aW9uOiBuIH0pLCBzKHRoaXMsICQsIFwiZlwiKS51cGRhdGUociksIHRoaXMubWFudWFsIHx8IHRoaXMuZGlkVXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoKHRoaXMsIFIsIHQsIFwiZlwiKSwgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KSwgdHlwZW9mIENTU1N0eWxlU2hlZXQgPCBcInVcIiAmJiB0aGlzLnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzKVxuICAgICAgICBPIHx8IChPID0gbmV3IENTU1N0eWxlU2hlZXQoKSwgTy5yZXBsYWNlU3luYyhvdCkpLCB0aGlzLnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW09dO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIG8udGV4dENvbnRlbnQgPSBvdCwgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKG8pO1xuICAgICAgfVxuICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHcoXCJzbG90XCIpKSwgaCh0aGlzLCBrLCBuZXcgbHQodGhpcywgZSwge1xuICAgICAgICBpbmVydDogITAsXG4gICAgICAgIGFyaWFIaWRkZW46IFwidHJ1ZVwiLFxuICAgICAgICBqdXN0aWZ5OiBcInJpZ2h0XCJcbiAgICAgIH0pLCBcImZcIiksIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzKHRoaXMsIGssIFwiZlwiKS5lbCksIGgodGhpcywgeCwgbmV3IHh0KHRoaXMsIGksIG4sIHtcbiAgICAgICAgaW5lcnQ6ICEwLFxuICAgICAgICBhcmlhSGlkZGVuOiBcInRydWVcIlxuICAgICAgfSksIFwiZlwiKSwgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHModGhpcywgeCwgXCJmXCIpLmVsKSwgaCh0aGlzLCAkLCBuZXcgbHQodGhpcywgciwge1xuICAgICAgICBpbmVydDogITAsXG4gICAgICAgIGFyaWFIaWRkZW46IFwidHJ1ZVwiLFxuICAgICAgICBqdXN0aWZ5OiBcImxlZnRcIlxuICAgICAgfSksIFwiZlwiKSwgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHModGhpcywgJCwgXCJmXCIpLmVsKTtcbiAgICB9XG4gICAgaCh0aGlzLCBCLCAhMCwgXCJmXCIpO1xuICB9XG4gIHdpbGxVcGRhdGUoKSB7XG4gICAgcyh0aGlzLCBrLCBcImZcIikud2lsbFVwZGF0ZSgpLCBzKHRoaXMsIHgsIFwiZlwiKS53aWxsVXBkYXRlKCksIHModGhpcywgJCwgXCJmXCIpLndpbGxVcGRhdGUoKTtcbiAgfVxuICBkaWRVcGRhdGUoKSB7XG4gICAgaWYgKCFzKHRoaXMsIEwsIFwiZlwiKSlcbiAgICAgIHJldHVybjtcbiAgICBzKHRoaXMsIFcsIFwiZlwiKSA/IHModGhpcywgVywgXCJmXCIpLmFib3J0KCkgOiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiYW5pbWF0aW9uc3N0YXJ0XCIpKSwgcyh0aGlzLCBrLCBcImZcIikuZGlkVXBkYXRlKCksIHModGhpcywgeCwgXCJmXCIpLmRpZFVwZGF0ZSgpLCBzKHRoaXMsICQsIFwiZlwiKS5kaWRVcGRhdGUoKTtcbiAgICBjb25zdCB0ID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIFByb21pc2UuYWxsKHRoaXMuc2hhZG93Um9vdC5nZXRBbmltYXRpb25zKCkubWFwKChlKSA9PiBlLmZpbmlzaGVkKSkudGhlbigoKSA9PiB7XG4gICAgICB0LnNpZ25hbC5hYm9ydGVkIHx8ICh0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiYW5pbWF0aW9uc2ZpbmlzaFwiKSksIGgodGhpcywgVywgdm9pZCAwLCBcImZcIikpO1xuICAgIH0pLCBoKHRoaXMsIFcsIHQsIFwiZlwiKTtcbiAgfVxufVxuUCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBCID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGsgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAkID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBMID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xua3QuZGVmYXVsdFByb3BzID0ge1xuICB0cmFuc2Zvcm1UaW1pbmc6IHtcbiAgICBkdXJhdGlvbjogOTAwLFxuICAgIC8vIE1ha2Ugc3VyZSB0byBrZWVwIHRoaXMgbWluaWZpZWQ6XG4gICAgZWFzaW5nOiBcImxpbmVhcigwLC4wMDUsLjAxOSwuMDM5LC4wNjYsLjA5NiwuMTI5LC4xNjUsLjIwMiwuMjQsLjI3OCwuMzE2LC4zNTQsLjM5LC40MjYsLjQ2MSwuNDk0LC41MjYsLjU1NywuNTg2LC42MTQsLjY0LC42NjUsLjY4OSwuNzExLC43MzEsLjc1MSwuNzY5LC43ODYsLjgwMiwuODE3LC44MzEsLjg0NCwuODU2LC44NjcsLjg3NywuODg3LC44OTYsLjkwNCwuOTEyLC45MTksLjkyNSwuOTMxLC45MzcsLjk0MiwuOTQ3LC45NTEsLjk1NSwuOTU5LC45NjIsLjk2NSwuOTY4LC45NzEsLjk3MywuOTc2LC45NzgsLjk4LC45ODEsLjk4MywuOTg0LC45ODYsLjk4NywuOTg4LC45ODksLjk5LC45OTEsLjk5MiwuOTkyLC45OTMsLjk5NCwuOTk0LC45OTUsLjk5NSwuOTk2LC45OTYsLjk5NjMsLjk5NjcsLjk5NjksLjk5NzIsLjk5NzUsLjk5NzcsLjk5NzksLjk5ODEsLjk5ODIsLjk5ODQsLjk5ODUsLjk5ODcsLjk5ODgsLjk5ODksMSlcIlxuICB9LFxuICBzcGluVGltaW5nOiB2b2lkIDAsXG4gIG9wYWNpdHlUaW1pbmc6IHsgZHVyYXRpb246IDQ1MCwgZWFzaW5nOiBcImVhc2Utb3V0XCIgfSxcbiAgYW5pbWF0ZWQ6ICEwLFxuICB0cmVuZDogITAsXG4gIGNvbnRpbnVvdXM6ICExLFxuICByZXNwZWN0TW90aW9uUHJlZmVyZW5jZTogITBcbn07XG5jbGFzcyB4dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIHsgY2xhc3NOYW1lOiBuLCAuLi5yIH0gPSB7fSkge1xuICAgIHRoaXMuZmxvdyA9IHQsIEguc2V0KHRoaXMsIHZvaWQgMCksIEUuc2V0KHRoaXMsIHZvaWQgMCksIE0uc2V0KHRoaXMsIHZvaWQgMCksIFYuc2V0KHRoaXMsIHZvaWQgMCksIFguc2V0KHRoaXMsIHZvaWQgMCksIGgodGhpcywgRSwgbmV3IHJ0KHQsIGUsIHtcbiAgICAgIGp1c3RpZnk6IFwicmlnaHRcIlxuICAgIH0pLCBcImZcIiksIGgodGhpcywgTSwgbmV3IHJ0KHQsIGksIHtcbiAgICAgIGp1c3RpZnk6IFwibGVmdFwiXG4gICAgfSksIFwiZlwiKSwgaCh0aGlzLCBILCB3KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwibnVtYmVyX19pbm5lclwiXG4gICAgfSwgW3ModGhpcywgRSwgXCJmXCIpLmVsLCBzKHRoaXMsIE0sIFwiZlwiKS5lbF0pLCBcImZcIiksIHRoaXMuZWwgPSB3KFwic3BhblwiLCB7XG4gICAgICAuLi5yLFxuICAgICAgY2xhc3NOYW1lOiBgbnVtYmVyICR7biA/PyBcIlwifWBcbiAgICB9LCBbcyh0aGlzLCBILCBcImZcIildKTtcbiAgfVxuICB3aWxsVXBkYXRlKCkge1xuICAgIGgodGhpcywgViwgdGhpcy5lbC5vZmZzZXRXaWR0aCwgXCJmXCIpLCBoKHRoaXMsIFgsIHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCwgXCJmXCIpLCBzKHRoaXMsIEUsIFwiZlwiKS53aWxsVXBkYXRlKCksIHModGhpcywgTSwgXCJmXCIpLndpbGxVcGRhdGUoKTtcbiAgfVxuICB1cGRhdGUoeyBpbnRlZ2VyOiB0LCBmcmFjdGlvbjogZSB9KSB7XG4gICAgcyh0aGlzLCBFLCBcImZcIikudXBkYXRlKHQpLCBzKHRoaXMsIE0sIFwiZlwiKS51cGRhdGUoZSk7XG4gIH1cbiAgZGlkVXBkYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHModGhpcywgRSwgXCJmXCIpLmRpZFVwZGF0ZSgpLCBzKHRoaXMsIE0sIFwiZlwiKS5kaWRVcGRhdGUoKTtcbiAgICBjb25zdCBlID0gcyh0aGlzLCBYLCBcImZcIikgLSB0LmxlZnQsIGkgPSB0aGlzLmVsLm9mZnNldFdpZHRoLCBuID0gcyh0aGlzLCBWLCBcImZcIikgLSBpO1xuICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoXCItLXdpZHRoXCIsIFN0cmluZyhpKSksIHRoaXMuZWwuYW5pbWF0ZSh7XG4gICAgICBbcV06IFtgJHtlfXB4YCwgXCIwcHhcIl0sXG4gICAgICBbbnRdOiBbbiwgMF1cbiAgICB9LCB7XG4gICAgICAuLi50aGlzLmZsb3cudHJhbnNmb3JtVGltaW5nLFxuICAgICAgY29tcG9zaXRlOiBcImFjY3VtdWxhdGVcIlxuICAgIH0pO1xuICB9XG59XG5IID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgTSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBWID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFggPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIGN0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgeyBqdXN0aWZ5OiBpLCBjbGFzc05hbWU6IG4sIC4uLnIgfSwgbCkge1xuICAgIHRoaXMuZmxvdyA9IHQsIHRoaXMuY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLm9uQ2hhclJlbW92ZSA9IChwKSA9PiAoKSA9PiB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShwKTtcbiAgICB9LCB6LnNldCh0aGlzLCB2b2lkIDApLCB0aGlzLmp1c3RpZnkgPSBpO1xuICAgIGNvbnN0IG8gPSBlLm1hcCgocCkgPT4gdGhpcy5hZGRDaGFyKHApLmVsKTtcbiAgICB0aGlzLmVsID0gdyhcInNwYW5cIiwge1xuICAgICAgLi4ucixcbiAgICAgIGNsYXNzTmFtZTogYHNlY3Rpb24gc2VjdGlvbi0tanVzdGlmeS0ke2l9ICR7biA/PyBcIlwifWBcbiAgICB9LCBsID8gbChvKSA6IG8pO1xuICB9XG4gIGFkZENoYXIodCwgeyBzdGFydERpZ2l0c0F0WmVybzogZSA9ICExLCAuLi5pIH0gPSB7fSkge1xuICAgIGNvbnN0IG4gPSB0LnR5cGUgPT09IFwiaW50ZWdlclwiIHx8IHQudHlwZSA9PT0gXCJmcmFjdGlvblwiID8gbmV3IGR0KHRoaXMsIHQudHlwZSwgZSA/IDAgOiB0LnZhbHVlLCB0LnBsYWNlLCB7XG4gICAgICAuLi5pLFxuICAgICAgb25SZW1vdmU6IHRoaXMub25DaGFyUmVtb3ZlKHQua2V5KVxuICAgIH0pIDogbmV3ICR0KHRoaXMsIHQudHlwZSwgdC52YWx1ZSwge1xuICAgICAgLi4uaSxcbiAgICAgIG9uUmVtb3ZlOiB0aGlzLm9uQ2hhclJlbW92ZSh0LmtleSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zZXQodC5rZXksIG4pLCBuO1xuICB9XG4gIHVucG9wKHQpIHtcbiAgICB0LmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWN0aW9uX19leGl0aW5nXCIpLCB0LmVsLnN0eWxlW3RoaXMuanVzdGlmeV0gPSBcIlwiO1xuICB9XG4gIHBvcCh0KSB7XG4gICAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLmVsLnN0eWxlW3RoaXMuanVzdGlmeV0gPSBgJHtwdChlLmVsLCB0aGlzLmp1c3RpZnkpfXB4YDtcbiAgICB9KSwgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLmVsLmNsYXNzTGlzdC5hZGQoXCJzZWN0aW9uX19leGl0aW5nXCIpLCBlLnByZXNlbnQgPSAhMTtcbiAgICB9KTtcbiAgfVxuICBhZGROZXdBbmRVcGRhdGVFeGlzdGluZyh0KSB7XG4gICAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBuID0gdGhpcy5qdXN0aWZ5ID09PSBcImxlZnRcIiwgciA9IG4gPyBcInByZXBlbmRcIiA6IFwiYXBwZW5kXCI7XG4gICAgaWYgKG10KHQsIChsKSA9PiB7XG4gICAgICBsZXQgbztcbiAgICAgIHRoaXMuY2hpbGRyZW4uaGFzKGwua2V5KSA/IChvID0gdGhpcy5jaGlsZHJlbi5nZXQobC5rZXkpLCBpLnNldChsLCBvKSwgdGhpcy51bnBvcChvKSwgby5wcmVzZW50ID0gITApIDogKG8gPSB0aGlzLmFkZENoYXIobCwgeyBzdGFydERpZ2l0c0F0WmVybzogITAsIGFuaW1hdGVJbjogITAgfSksIGUuc2V0KGwsIG8pKSwgdGhpcy5lbFtyXShvLmVsKTtcbiAgICB9LCB7IHJldmVyc2U6IG4gfSksIHRoaXMuZmxvdy5jb21wdXRlZEFuaW1hdGVkKSB7XG4gICAgICBjb25zdCBsID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGUuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBvLndpbGxVcGRhdGUobCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZS5mb3JFYWNoKChsLCBvKSA9PiB7XG4gICAgICBsLnVwZGF0ZShvLnZhbHVlKTtcbiAgICB9KSwgaS5mb3JFYWNoKChsLCBvKSA9PiB7XG4gICAgICBsLnVwZGF0ZShvLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICB3aWxsVXBkYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGgodGhpcywgeiwgdFt0aGlzLmp1c3RpZnldLCBcImZcIiksIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoZSkgPT4gZS53aWxsVXBkYXRlKHQpKTtcbiAgfVxuICBkaWRVcGRhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChuKSA9PiBuLmRpZFVwZGF0ZSh0KSk7XG4gICAgY29uc3QgZSA9IHRbdGhpcy5qdXN0aWZ5XSwgaSA9IHModGhpcywgeiwgXCJmXCIpIC0gZTtcbiAgICB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgdHJhbnNmb3JtOiBbYHRyYW5zbGF0ZVgoJHtpfXB4KWAsIFwibm9uZVwiXVxuICAgIH0sIHtcbiAgICAgIC4uLnRoaXMuZmxvdy50cmFuc2Zvcm1UaW1pbmcsXG4gICAgICBjb21wb3NpdGU6IFwiYWNjdW11bGF0ZVwiXG4gICAgfSk7XG4gIH1cbn1cbnogPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIHJ0IGV4dGVuZHMgY3Qge1xuICB1cGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoaSwgbikgPT4ge1xuICAgICAgdC5maW5kKChyKSA9PiByLmtleSA9PT0gbikgfHwgZS5zZXQobiwgaSksIHRoaXMudW5wb3AoaSk7XG4gICAgfSksIHRoaXMuYWRkTmV3QW5kVXBkYXRlRXhpc3RpbmcodCksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaSBpbnN0YW5jZW9mIGR0ICYmIGkudXBkYXRlKDApO1xuICAgIH0pLCB0aGlzLnBvcChlKTtcbiAgfVxufVxuY2xhc3MgbHQgZXh0ZW5kcyBjdCB7XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChpLCBuKSA9PiB7XG4gICAgICB0LmZpbmQoKHIpID0+IHIua2V5ID09PSBuKSB8fCBlLnNldChuLCBpKTtcbiAgICB9KSwgdGhpcy5wb3AoZSksIHRoaXMuYWRkTmV3QW5kVXBkYXRlRXhpc3RpbmcodCk7XG4gIH1cbn1cbmNsYXNzIHN0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgeyBvblJlbW92ZTogaSwgYW5pbWF0ZUluOiBuID0gITEgfSA9IHt9KSB7XG4gICAgdGhpcy5mbG93ID0gdCwgdGhpcy5lbCA9IGUsIGouc2V0KHRoaXMsICEwKSwgSS5zZXQodGhpcywgdm9pZCAwKSwgVC5zZXQodGhpcywgKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICB0aGlzLmVsLnJlbW92ZSgpLCAociA9IHModGhpcywgSSwgXCJmXCIpKSA9PSBudWxsIHx8IHIuY2FsbCh0aGlzKTtcbiAgICB9KSwgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiYW5pbWF0ZS1wcmVzZW5jZVwiKSwgdGhpcy5mbG93LmNvbXB1dGVkQW5pbWF0ZWQgJiYgbiAmJiB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgW1pdOiBbLTAuOTk5OSwgMF1cbiAgICB9LCB7XG4gICAgICAuLi50aGlzLmZsb3cub3BhY2l0eVRpbWluZyxcbiAgICAgIGNvbXBvc2l0ZTogXCJhY2N1bXVsYXRlXCJcbiAgICB9KSwgaCh0aGlzLCBJLCBpLCBcImZcIik7XG4gIH1cbiAgZ2V0IHByZXNlbnQoKSB7XG4gICAgcmV0dXJuIHModGhpcywgaiwgXCJmXCIpO1xuICB9XG4gIHNldCBwcmVzZW50KHQpIHtcbiAgICBpZiAocyh0aGlzLCBqLCBcImZcIikgIT09IHQpIHtcbiAgICAgIGlmIChoKHRoaXMsIGosIHQsIFwiZlwiKSwgIXRoaXMuZmxvdy5jb21wdXRlZEFuaW1hdGVkKSB7XG4gICAgICAgIHQgfHwgcyh0aGlzLCBULCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tX251bWJlci1mbG93LWQtb3BhY2l0eVwiLCB0ID8gXCIwXCIgOiBcIi0uOTk5XCIpLCB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgICBbWl06IHQgPyBbLTAuOTk5OSwgMF0gOiBbMC45OTksIDBdXG4gICAgICB9LCB7XG4gICAgICAgIC4uLnRoaXMuZmxvdy5vcGFjaXR5VGltaW5nLFxuICAgICAgICBjb21wb3NpdGU6IFwiYWNjdW11bGF0ZVwiXG4gICAgICB9KSwgdCA/IHRoaXMuZmxvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc2ZpbmlzaFwiLCBzKHRoaXMsIFQsIFwiZlwiKSkgOiB0aGlzLmZsb3cuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnNmaW5pc2hcIiwgcyh0aGlzLCBULCBcImZcIiksIHtcbiAgICAgICAgb25jZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuaiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIGZ0IGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpLCBuKSB7XG4gICAgc3VwZXIodC5mbG93LCBpLCBuKSwgdGhpcy5zZWN0aW9uID0gdCwgdGhpcy52YWx1ZSA9IGUsIHRoaXMuZWwgPSBpO1xuICB9XG59XG5jbGFzcyBkdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSwgbiwgcikge1xuICAgIGNvbnN0IGwgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9KS5tYXAoKHAsIHUpID0+IHtcbiAgICAgIGNvbnN0IG0gPSB3KFwic3BhblwiLCB7IGNsYXNzTmFtZTogYGRpZ2l0X19udW0ke3UgPT09IGkgPyBcIiBpcy1jdXJyZW50XCIgOiBcIlwifWAgfSwgW2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyh1KSldKTtcbiAgICAgIHJldHVybiBtLnN0eWxlLnNldFByb3BlcnR5KFwiLS1uXCIsIFN0cmluZyh1KSksIG07XG4gICAgfSksIG8gPSB3KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiZGlnaXRcIlxuICAgIH0sIGwpO1xuICAgIG8uc3R5bGUuc2V0UHJvcGVydHkoXCItLWN1cnJlbnRcIiwgU3RyaW5nKGkpKSwgc3VwZXIodCwgaSwgbywgciksIHRoaXMucGxhY2UgPSBuLCBBLnNldCh0aGlzLCB2b2lkIDApLCBfLnNldCh0aGlzLCB2b2lkIDApLCBHLnNldCh0aGlzLCB2b2lkIDApLCBpdC5zZXQodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtc3Bpbm5pbmdcIik7XG4gICAgfSksIGgodGhpcywgQSwgbCwgXCJmXCIpO1xuICB9XG4gIHdpbGxVcGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGgodGhpcywgXywgdGhpcy52YWx1ZSwgXCJmXCIpO1xuICAgIGNvbnN0IGkgPSBlW3RoaXMuc2VjdGlvbi5qdXN0aWZ5XSAtIHRbdGhpcy5zZWN0aW9uLmp1c3RpZnldLCBuID0gZS53aWR0aCAvIDI7XG4gICAgaCh0aGlzLCBHLCB0aGlzLnNlY3Rpb24uanVzdGlmeSA9PT0gXCJsZWZ0XCIgPyBpICsgbiA6IGkgLSBuLCBcImZcIik7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICB2YXIgZSwgaTtcbiAgICAoZSA9IHModGhpcywgQSwgXCJmXCIpW3RoaXMudmFsdWVdKSA9PSBudWxsIHx8IGUuY2xhc3NMaXN0LnJlbW92ZShcImlzLWN1cnJlbnRcIiksIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoXCItLWN1cnJlbnRcIiwgU3RyaW5nKHQpKSwgKGkgPSBzKHRoaXMsIEEsIFwiZlwiKVt0XSkgPT0gbnVsbCB8fCBpLmNsYXNzTGlzdC5hZGQoXCJpcy1jdXJyZW50XCIpLCB0aGlzLnZhbHVlID0gdDtcbiAgfVxuICBkaWRVcGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBpID0gZVt0aGlzLnNlY3Rpb24uanVzdGlmeV0gLSB0W3RoaXMuc2VjdGlvbi5qdXN0aWZ5XSwgbiA9IGUud2lkdGggLyAyLCByID0gdGhpcy5zZWN0aW9uLmp1c3RpZnkgPT09IFwibGVmdFwiID8gaSArIG4gOiBpIC0gbjtcbiAgICB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgdHJhbnNmb3JtOiBbYHRyYW5zbGF0ZVgoJHtzKHRoaXMsIEcsIFwiZlwiKSAtIHJ9cHgpYCwgXCJub25lXCJdXG4gICAgfSwge1xuICAgICAgLi4udGhpcy5mbG93LnRyYW5zZm9ybVRpbWluZyxcbiAgICAgIGNvbXBvc2l0ZTogXCJhY2N1bXVsYXRlXCJcbiAgICB9KTtcbiAgICBjb25zdCBsID0gdGhpcy5kaWZmO1xuICAgIGwgJiYgKHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImlzLXNwaW5uaW5nXCIpLCB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgW2F0XTogWy1sLCAwXVxuICAgIH0sIHtcbiAgICAgIC4uLnRoaXMuZmxvdy5zcGluVGltaW5nID8/IHRoaXMuZmxvdy50cmFuc2Zvcm1UaW1pbmcsXG4gICAgICBjb21wb3NpdGU6IFwiYWNjdW11bGF0ZVwiXG4gICAgfSksIHRoaXMuZmxvdy5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc2ZpbmlzaFwiLCBzKHRoaXMsIGl0LCBcImZcIiksIHsgb25jZTogITAgfSkpO1xuICB9XG4gIGdldCBkaWZmKCkge1xuICAgIGxldCB0ID0gdGhpcy5mbG93LmNvbXB1dGVkVHJlbmQ7XG4gICAgY29uc3QgZSA9IHRoaXMudmFsdWUgLSBzKHRoaXMsIF8sIFwiZlwiKTtcbiAgICByZXR1cm4gIWUgJiYgdGhpcy5mbG93LnN0YXJ0aW5nUGxhY2UgIT0gbnVsbCAmJiB0aGlzLmZsb3cuc3RhcnRpbmdQbGFjZSA+PSB0aGlzLnBsYWNlID8gMTAgKiB0IDogKHQgfHwgKHQgPSBNYXRoLnNpZ24oZSkpLCB0ID09PSBiLkRPV04gJiYgdGhpcy52YWx1ZSA+IHModGhpcywgXywgXCJmXCIpID8gdGhpcy52YWx1ZSAtIDEwIC0gcyh0aGlzLCBfLCBcImZcIikgOiB0ID09PSBiLlVQICYmIHRoaXMudmFsdWUgPCBzKHRoaXMsIF8sIFwiZlwiKSA/IDEwIC0gcyh0aGlzLCBfLCBcImZcIikgKyB0aGlzLnZhbHVlIDogZSk7XG4gIH1cbn1cbkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBHID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGl0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyAkdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSwgbikge1xuICAgIGNvbnN0IHIgPSB3KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwic3ltYm9sX192YWx1ZVwiLFxuICAgICAgdGV4dENvbnRlbnQ6IGlcbiAgICB9KTtcbiAgICBzdXBlcih0LCBpLCB3KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwic3ltYm9sXCJcbiAgICB9LCBbcl0pLCBuKSwgdGhpcy50eXBlID0gZSwgdi5zZXQodGhpcywgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIFkuc2V0KHRoaXMsIHZvaWQgMCksIEsuc2V0KHRoaXMsIChsKSA9PiAoKSA9PiB7XG4gICAgICBzKHRoaXMsIHYsIFwiZlwiKS5kZWxldGUobCk7XG4gICAgfSksIHModGhpcywgdiwgXCJmXCIpLnNldChpLCBuZXcgc3QodGhpcy5mbG93LCByLCB7XG4gICAgICBvblJlbW92ZTogcyh0aGlzLCBLLCBcImZcIikuY2FsbCh0aGlzLCBpKVxuICAgIH0pKTtcbiAgfVxuICB3aWxsVXBkYXRlKHQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSBcImRlY2ltYWxcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBoKHRoaXMsIFksIGVbdGhpcy5zZWN0aW9uLmp1c3RpZnldIC0gdFt0aGlzLnNlY3Rpb24uanVzdGlmeV0sIFwiZlwiKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIGlmICh0aGlzLnZhbHVlICE9PSB0KSB7XG4gICAgICBjb25zdCBlID0gcyh0aGlzLCB2LCBcImZcIikuZ2V0KHRoaXMudmFsdWUpO1xuICAgICAgaWYgKGUucHJlc2VudCA9ICExLCBlLmVsLmNsYXNzTGlzdC5hZGQoXCJzeW1ib2xfX2V4aXRpbmdcIiksIHModGhpcywgdiwgXCJmXCIpLmhhcyh0KSkge1xuICAgICAgICBjb25zdCBpID0gcyh0aGlzLCB2LCBcImZcIikuZ2V0KHQpO1xuICAgICAgICBpLnByZXNlbnQgPSAhMCwgaS5lbC5jbGFzc0xpc3QucmVtb3ZlKFwic3ltYm9sX19leGl0aW5nXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaSA9IHcoXCJzcGFuXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwic3ltYm9sX192YWx1ZVwiLFxuICAgICAgICAgIHRleHRDb250ZW50OiB0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGkpLCBzKHRoaXMsIHYsIFwiZlwiKS5zZXQodCwgbmV3IHN0KHRoaXMuZmxvdywgaSwge1xuICAgICAgICAgIGFuaW1hdGVJbjogITAsXG4gICAgICAgICAgb25SZW1vdmU6IHModGhpcywgSywgXCJmXCIpLmNhbGwodGhpcywgdClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdDtcbiAgfVxuICBkaWRVcGRhdGUodCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFwiZGVjaW1hbFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMuc2VjdGlvbi5qdXN0aWZ5XSAtIHRbdGhpcy5zZWN0aW9uLmp1c3RpZnldO1xuICAgIHRoaXMuZWwuYW5pbWF0ZSh7XG4gICAgICB0cmFuc2Zvcm06IFtgdHJhbnNsYXRlWCgke3ModGhpcywgWSwgXCJmXCIpIC0gaX1weClgLCBcIm5vbmVcIl1cbiAgICB9LCB7IC4uLnRoaXMuZmxvdy50cmFuc2Zvcm1UaW1pbmcsIGNvbXBvc2l0ZTogXCJhY2N1bXVsYXRlXCIgfSk7XG4gIH1cbn1cbnYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgWSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBLID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5leHBvcnQge1xuICBrdCBhcyBOdW1iZXJGbG93TGl0ZSxcbiAgU3QgYXMgY2FuQW5pbWF0ZSxcbiAgRXQgYXMgZGVmaW5lLFxuICBNdCBhcyBwYXJ0aXRpb25QYXJ0cyxcbiAgUSBhcyBwcmVmZXJzUmVkdWNlZE1vdGlvbixcbiAgTnQgYXMgcmVuZGVyXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-flow/dist/index.mjs\n");

/***/ })

};
;